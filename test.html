<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML 解析测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .result {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            margin-top: 10px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <h1>XML 解析测试</h1>

    <div class="test-section">
        <h3>测试 XML 解析</h3>
        <button onclick="testXMLParsing()">测试解析</button>
        <div id="parseResult" class="result"></div>
    </div>

    <div class="test-section">
        <h3>测试分页排版</h3>
        <button onclick="testPagination()">测试分页</button>
        <div id="pageResult" class="result"></div>
    </div>

    <script>
        // XML 解析工具类
        class XMLParser {
            static parse(xmlString) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

                const parseError = xmlDoc.getElementsByTagName('parsererror');
                if (parseError.length > 0) {
                    throw new Error('XML 解析失败');
                }

                return this.parseNode(xmlDoc.documentElement);
            }

            static parseNode(node) {
                const result = {
                    tagName: node.tagName,
                    attributes: {},
                    content: '',
                    children: []
                };

                for (let i = 0; i < node.attributes.length; i++) {
                    const attr = node.attributes[i];
                    result.attributes[attr.name] = attr.value;
                }

                for (let i = 0; i < node.childNodes.length; i++) {
                    const child = node.childNodes[i];

                    if (child.nodeType === Node.TEXT_NODE) {
                        const text = child.textContent.trim();
                        if (text) {
                            result.content += text;
                        }
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        result.children.push(this.parseNode(child));
                    }
                }

                return result;
            }

            static toHTML(parsedData) {
                if (!parsedData) return '';

                let html = '';

                if (parsedData.tagName === 'title') {
                    html += `<h1 class="article-title">${parsedData.content}</h1>`;
                }

                if (parsedData.tagName === 'body') {
                    html += '<div class="article-body">';
                    parsedData.children.forEach(child => {
                        if (child.tagName === 'p') {
                            html += `<p id="p-${child.attributes.id || ''}" class="paragraph">${child.content}</p>`;
                        } else if (child.tagName === 'img') {
                            html += `<img src="${child.attributes.src || ''}" alt="${child.attributes.alt || ''}" class="article-image" />`;
                        } else if (child.tagName === 'h1' || child.tagName === 'h2' || child.tagName === 'h3') {
                            html += `<${child.tagName} class="heading">${child.content}</${child.tagName}>`;
                        }
                    });
                    html += '</div>';
                }

                parsedData.children.forEach(child => {
                    html += this.toHTML(child);
                });

                return html;
            }
        }

        // 分页排版工具类
        class PageLayout {
            constructor() {
                this.pageSizes = {
                    A4: { width: 210, height: 297, unit: 'mm' }
                };
                this.currentPageSize = 'A4';
                this.margin = { top: 20, right: 20, bottom: 20, left: 20, unit: 'mm' };
                this.lineHeight = 1.5;
                this.fontSize = 14;
            }

            mmToPx(mm) {
                return (mm * 96) / 25.4;
            }

            getContentArea() {
                const pageSize = this.pageSizes[this.currentPageSize];
                const width = this.mmToPx(pageSize.width - this.margin.left - this.margin.right);
                const height = this.mmToPx(pageSize.height - this.margin.top - this.margin.bottom);

                return { width, height };
            }

            paginate(htmlContent) {
                const pages = [];
                const contentArea = this.getContentArea();

                const tempContainer = document.createElement('div');
                tempContainer.style.cssText = `
                    position: absolute;
                    top: -9999px;
                    left: -9999px;
                    width: ${contentArea.width}px;
                    font-size: ${this.fontSize}px;
                    line-height: ${this.lineHeight};
                    overflow: hidden;
                `;
                tempContainer.innerHTML = htmlContent;
                document.body.appendChild(tempContainer);

                const elements = Array.from(tempContainer.children);
                let currentPage = [];
                let currentHeight = 0;

                elements.forEach(element => {
                    const elementHeight = element.offsetHeight;

                    if (currentHeight + elementHeight > contentArea.height) {
                        if (currentPage.length > 0) {
                            pages.push(this.createPage(currentPage));
                            currentPage = [];
                            currentHeight = 0;
                        }
                    }

                    currentPage.push(element);
                    currentHeight += elementHeight;
                });

                if (currentPage.length > 0) {
                    pages.push(this.createPage(currentPage));
                }

                document.body.removeChild(tempContainer);
                return pages;
            }

            createPage(elements) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'page';

                elements.forEach(element => {
                    pageDiv.appendChild(element.cloneNode(true));
                });

                return {
                    element: pageDiv,
                    content: pageDiv.innerHTML
                };
            }
        }

        function testXMLParsing() {
            const testXML = `<?xml version="1.0" encoding="utf-8" standalone="no"?>
<article id="2" type="standard" filename="result" version="2.1.1.1">
    <title>前言</title>
    <body>
        <p id="1">本文件按照GB/T 1.1—2020《标准化工作导则第1部分：标准化文件的结构和起草规则》的规定起草。</p>
        <p id="2">本文件代替GY/T 222—2006《数字电视转播车技术要求和测量方法》，与GY/T 222—2006相比，除结构调整和编辑性改动外，主要技术变化如下：</p>
        <p id="3">——更改了规范性引用文件清单（见第2章，2006年版的第2章）；</p>
    </body>
</article>`;

            try {
                const parsedData = XMLParser.parse(testXML);
                const htmlContent = XMLParser.toHTML(parsedData);

                document.getElementById('parseResult').innerHTML = `
                    <h4>解析成功！</h4>
                    <p><strong>解析结果：</strong></p>
                    <pre>${JSON.stringify(parsedData, null, 2)}</pre>
                    <p><strong>HTML 输出：</strong></p>
                    <div style="border: 1px solid #ccc; padding: 10px; background: white;">${htmlContent}</div>
                `;
            } catch (error) {
                document.getElementById('parseResult').innerHTML = `<p style="color: red;">解析失败：${error.message}</p>`;
            }
        }

        function testPagination() {
            const testHTML = `
                <h1 class="article-title">测试标题</h1>
                <div class="article-body">
                    <p class="paragraph">这是第一段内容，用于测试分页功能。</p>
                    <p class="paragraph">这是第二段内容，继续测试分页功能。</p>
                    <p class="paragraph">这是第三段内容，测试分页算法是否正常工作。</p>
                    <p class="paragraph">这是第四段内容，验证分页逻辑。</p>
                    <p class="paragraph">这是第五段内容，确保分页功能完整。</p>
                </div>
            `;

            try {
                const pageLayout = new PageLayout();
                const pages = pageLayout.paginate(testHTML);

                document.getElementById('pageResult').innerHTML = `
                    <h4>分页成功！</h4>
                    <p><strong>总页数：</strong>${pages.length}</p>
                    <p><strong>页面内容：</strong></p>
                    ${pages.map((page, index) => `
                        <div style="border: 1px solid #ccc; margin: 10px 0; padding: 10px; background: white;">
                            <h5>第 ${index + 1} 页</h5>
                            ${page.content}
                        </div>
                    `).join('')}
                `;
            } catch (error) {
                document.getElementById('pageResult').innerHTML = `<p style="color: red;">分页失败：${error.message}</p>`;
            }
        }
    </script>
</body>
</html>